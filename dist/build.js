mod=(a,b)=>(a%b+b)%b;createAnimationFPSThrottler=()=>{let a=window.performance.now();const b=1E3/60;return{requestAnimationFrame:c=>{const f=Math.max(0,b-(window.performance.now()-a));let k=()=>{a=window.performance.now();c()};setTimeout(()=>requestAnimationFrame(k),f)}}};const origin={x:0,y:0,z:0};
class Vector{constructor(a,b){b||(b=a,a=origin);this.x=b.x-a.x;this.y=b.y-a.y;this.z=b.z-a.z}add(a){return new Vector(origin,{x:this.x+a.x,y:this.y+a.y,z:this.z+a.z})}subtract(a){return this.add({x:-a.x,y:-a.y,z:-a.z})}multiply(a){return new Vector(origin,{x:this.x*a,y:this.y*a,z:this.z*a})}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}unit(){return this.multiply(1/this.magnitude())}cross(a){return new Vector(origin,{x:this.y*a.z-this.z*a.y,y:this.z*a.x-this.x*a.z,z:this.x*
a.y-this.y*a.x})}}const qDimensions=["w","x","y","z"],qProductSign=[[1,1,1,1],[1,-1,1,-1],[1,-1,-1,1],[1,1,-1,-1]],qProductAxis=[[0,1,2,3],[1,0,3,2],[2,3,0,1],[3,2,1,0]];class Quaternion{constructor(a,b,c,f){this.w=a;this.x=b;this.y=c;this.z=f}conjugate(){return new Quaternion(this.w,-this.x,-this.y,-this.z)}multiply(a){const b=new Quaternion(0,0,0,0);for(let c=0;4>c;c++)for(let f=0;4>f;f++)b[qDimensions[qProductAxis[c][f]]]+=qProductSign[c][f]*this[qDimensions[c]]*a[qDimensions[f]];return b}}
class Point{constructor(a,b,c,f){this.base={x:a,y:b,z:c};this.x=a;this.y=b;this.z=c;this.id=f}update(a){const {x:b,y:c,z:f}=this.rotateAroundAxis(this.base,a.axis.unit(),a.angle);this.x=b;this.y=c;this.z=f}saveOrientation(a){this.update(a);this.base.x=this.x;this.base.y=this.y;this.base.z=this.z}clone(){return new Point(this.x,this.y,this.z,this.id)}rotateAroundAxis(a,b,c){const f=Math.sin(c/2);b=new Quaternion(Math.cos(c/2),f*b.x,f*b.y,f*b.z);a=new Quaternion(0,a.x,a.y,a.z);a=b.multiply(a).multiply(b.conjugate());
return new Point(a.x,a.y,a.z)}}class ColorData{constructor(a,b){this.code=a;this.originalStickerId=b}}
class Sticker{constructor(a,b,c){this.id=a;this.colorData=new ColorData(b,this.id);this.points=c;this.attractor={}}contains(a){var b=this.points[this.points.length-1];let c=0;for(const f of this.points){b=(new Vector(b,f)).cross(new Vector(b,a));if(0>c&&0<b.z||0<c&&0>b.z)return!1;0!==b.z&&(c=b.z);b=f}return!0}calculateNormalVector(){return(new Vector(this.points[0],this.points[1])).cross(new Vector(this.points[0],this.points[this.points.length-1]))}update(a){this.points.forEach(b=>b.update(a));this.attractor=
{x:this.points.reduce((b,c)=>b+c.x,0),y:this.points.reduce((b,c)=>b+c.y,0),z:this.points.reduce((b,c)=>b+c.z,0)}}getPointProjection(a,b,c){a=[a.x,a.y];c&&(a[0]+=(this.attractor.x-a[0])/(10*this.points.length),a[1]+=(this.attractor.y-a[1])/(10*this.points.length));b&&(a[0]=-a[0]);return a}render(a,b,c){a.fillStyle=this.colorData.code;a.strokeStyle="#202020";a.beginPath();a.moveTo(...this.getPointProjection(this.points[0],b,c));this.points.forEach(f=>a.lineTo(...this.getPointProjection(f,b,c)));a.closePath();
a.fill();a.stroke()}}class Face{constructor(a){this.stickers=a;this.normalVector=this.stickers[0].calculateNormalVector()}update(a){this.stickers.forEach(b=>b.update(a));this.normalVector=this.stickers[0].calculateNormalVector()}render(a,b,c){this.stickers.forEach(f=>f.render(a,b,c))}}
class Cycle{constructor(a,b,c,f,k){this.index=a;this.stickerCollections=b;this.period=c;this.unitVector=f;this.animationConfig=k;this.stickerCover={}}computeStickerCover(){this.stickerCollections.forEach(a=>a.forEach(({id:b})=>this.stickerCover[b]=!0))}saveOrientation(a){const b=new Point(this.unitVector.x,this.unitVector.y,this.unitVector.z);b.update(a);this.unitVector=new Vector(b)}twist(a=1){this.stickerCollections.forEach(b=>{if(1!==b.length){var c=a*b.length/this.period;b.forEach((f,k)=>{f.$newColorData=
b[mod(k-c,b.length)].colorData});b.forEach(f=>{f.colorData=f.$newColorData;delete f.$newColorData})}})}}
class Puzzle{constructor(a,b,c,f){this.displayName=a;this.displaySize=b;this.faces=c;this.cycles=f;this.twisting=this.rotating=!1;this.startEvtCoordinates={};this.baseOrientation={axis:new Vector({x:1,y:0,z:0}),angle:0};this.animationState={active:!1,counter:0,direction:void 0,cycle:void 0};this.stickers=[].concat(...this.faces.map(k=>k.stickers));this.clearStats();this.cycleMap={};this.processCycleMap();this.startSticker=void 0}clearStats(){this.startTime=void 0;this.movesMade=0}isSolved(){for(let a=
0;a<this.faces.length;a++)for(let b=0;b<this.faces[a].stickers.length;b++)if(this.faces[a].stickers[b].colorData.code!==this.faces[a].stickers[0].colorData.code)return!1;return!0}processCycleMap(){this.cycles.forEach(a=>a.stickerCollections.forEach(b=>{b.isPrimary&&b.forEach(c=>{this.cycleMap[c.id]=this.cycleMap[c.id]||[];this.cycleMap[c.id].push(a)})}))}update(){if(this.animationState.active&&this.animationState.counter<(window.animate?this.animationState.cycle.animationConfig.steps:1)){const a=
{axis:this.animationState.cycle.unitVector,angle:this.animationState.direction*this.animationState.counter*this.animationState.cycle.animationConfig.dAlpha};this.stickers.forEach(b=>{this.animationState.cycle.stickerCover[b.id]&&b.update(a)});this.stickers.sort((b,c)=>c.attractor.z-b.attractor.z);this.animationState.counter++}else if(this.faces.forEach(a=>a.update(this.updatedOrientation||this.baseOrientation)),this.faces.sort((a,b)=>b.normalVector.z-a.normalVector.z),this.animationState.active){this.animationState.cycle.twist(this.animationState.direction);
this.startTime&&this.isSolved()?(this.onFinish&&this.onFinish(((new Date).getTime()-this.startTime)/1E3),this.clearStats()):this.startTime&&this.movesMade++;if(this.animationState.callback&&(this.animationState.callback(),this.animationState.counter<(window.animate?this.animationState.cycle.animationConfig.steps:1)))return this.update();this.animationState={active:!1,counter:0,direction:void 0,cycle:void 0}}}findTouchedSticker(a,b){let c;for(let f=this.faces.length-1;0<=f&&!(0<=this.faces[f].normalVector.z);f--)if(c=
this.faces[f].stickers.find(k=>k.contains({x:a,y:b,z:0})))if(window.pointAndSwap)if(window.tempS){const k=c.colorData;c.colorData=window.tempS.colorData;window.tempS.colorData=k;window.tempS=void 0}else window.tempS=c;else return c}grab(a,b,c){this.startEvtCoordinates.x=a;this.startEvtCoordinates.y=b;2===c?this.rotating=!0:(this.startSticker=this.findTouchedSticker(a,b),this.twisting=!!this.startSticker,this.rotating=!this.startSticker)}drag(a,b){if(!this.animationState.active)if(this.rotating){if(a=
(a-this.startEvtCoordinates.x)/100,b=(b-this.startEvtCoordinates.y)/100,a||b)b=new Vector({x:b,y:-a,z:0}),this.updatedOrientation={axis:b,angle:b.magnitude()}}else this.twisting&&(b=new Vector(new Point(this.startEvtCoordinates.x,this.startEvtCoordinates.y,0),new Point(a,b,0)),20<b.magnitude()&&(window.clearSolution(),this.detectCycle(b)))}detectCycle(a){if(this.cycleMap[this.startSticker.id]){var b=0,c,f;this.cycleMap[this.startSticker.id].forEach(k=>{var h=new Point(k.unitVector.x,k.unitVector.y,
k.unitVector.z);h.z=0;h=new Vector(h);h=a.cross(h);b<h.magnitude()&&(b=h.magnitude(),c=k,f=0<h.z?-1:1)});this.animateAndTwist(c,f);this.release()}}animateAndTwist(a,b){if(this.animationState.active)return!1;this.animationState={active:!0,counter:0,direction:b,cycle:a};return!0}release(){this.twisting=this.rotating=!1;this.startEvtCoordinates={};this.updatedOrientation&&(this.saveOrientation(this.updatedOrientation),this.updatedOrientation=void 0);this.startSticker=void 0}saveOrientation(a){this.stickers.forEach(b=>
b.points.forEach(c=>c.saveOrientation(a)));this.cycles.forEach(b=>b.saveOrientation(a))}scramble(){this.clearStats();window.hideStartButton();const a=3*this.cycles.length,b=[];for(let f=0;f<a;f++)b.push({cycle:this.cycles[Math.floor(Math.random()*this.cycles.length)],direction:.5>Math.random()?-1:1});const c=[];window.clearSolution();window.disableSolveButton();b.forEach(({cycle:f,direction:k},h)=>{h&&f===b[h-1].cycle&&(k=b[h-1].direction);c.push({active:!0,counter:0,direction:k,cycle:f,callback:h<
a-1?()=>this.animationState=c[h+1]:()=>{window.showStartButton();window.enableSolveButton();this.startTime=(new Date).getTime()}})});this.animationState=c[0]}render(a,b,c=!0){if(this.animationState.active){const [k,h,n]=b?[this.stickers.length-1,-1,-1]:[0,this.stickers.length,1];for(f=k;f!==h;f+=n)this.stickers[f].render(a,b,c)}else{const [k,h,n]=b?[this.faces.length-1,-1,-1]:[0,this.faces.length,1];for(var f=k;f!==h;f+=n)this.faces[f].render(a,b,c)}}}
class Cube extends Puzzle{constructor(a=2,b=250){const c=b/a,f=b/2,k={steps:10,dAlpha:Math.PI/2/10},h={},n=[];b=[{slices:[{fIndex:1,sIndex:0,sJump:a,cJump:1},{fIndex:3,sIndex:a-1,sJump:-1,cJump:a},{fIndex:0,sIndex:(a-1)*a,sJump:-a,cJump:1},{fIndex:2,sIndex:0,sJump:1,cJump:a}],attachedFaces:{ffIndex:4,lfIndex:5,iStep:a,jStep:1},unitVector:new Vector(new Point(0,0,1))},{slices:[{fIndex:1,sIndex:0,sJump:1,cJump:a},{fIndex:5,sIndex:(a-1)*a,sJump:-a,cJump:1},{fIndex:0,sIndex:a-1,sJump:-1,cJump:a},{fIndex:4,
sIndex:0,sJump:a,cJump:1}],attachedFaces:{ffIndex:2,lfIndex:3,iStep:1,jStep:a},unitVector:new Vector(new Point(0,-1,0))},{slices:[{fIndex:2,sIndex:0,sJump:a,cJump:1},{fIndex:5,sIndex:0,sJump:1,cJump:a},{fIndex:3,sIndex:(a-1)*a,sJump:-a,cJump:1},{fIndex:4,sIndex:a-1,sJump:-1,cJump:a}],attachedFaces:{ffIndex:0,lfIndex:1,iStep:1,jStep:a},unitVector:new Vector(new Point(-1,0,0))}];const w=[{key:"iStep",dir:1},{key:"jStep",dir:1},{key:"iStep",dir:-1},{key:"jStep",dir:-1}];let D,C,u,m,t,p;[{fixed:"x",direction:-1,
variable:["y","z"],color:"yellow"},{fixed:"x",direction:1,variable:["y","z"],color:"white"},{fixed:"y",direction:-1,variable:["z","x"],color:"blue"},{fixed:"y",direction:1,variable:["z","x"],color:"lawngreen"},{fixed:"z",direction:-1,variable:["x","y"],color:"red"},{fixed:"z",direction:1,variable:["x","y"],color:"darkorange"}].forEach((v,z)=>{const E=[];D=-f;for(let B=0;B<=a;B++){C=-f;for(let y=0;y<=a;y++)m=`p-${z}-${B}-${y}`,u={},u[v.fixed]=v.direction*f,u[v.variable[0]]=D,u[v.variable[1]]=C,h[m]=
new Point(u.x,u.y,u.z,m),B&&y&&(t=`s-${z}-${B}-${y}`,p=[h[`p-${z}-${B}-${y}`].clone(),h[`p-${z}-${B-1}-${y}`].clone(),h[`p-${z}-${B-1}-${y-1}`].clone(),h[`p-${z}-${B}-${y-1}`].clone()],-1===v.direction&&p.reverse(),E.push(new Sticker(t,v.color,p))),C+=c;D+=c}n.push(new Face(E))});const e=[];let d,g,l,q,r,x,A;b.forEach(v=>{for(let z=0;z<a;z++)d=new Cycle(e.length,[],4,v.unitVector,k),g=[],v.slices.forEach(E=>{for(let B=0;B<a;B++)l=E.sIndex+B*E.sJump+z*E.cJump,g.push(n[E.fIndex].stickers[l])}),d.stickerCollections.push(g),
e.push(d);q=e[e.length-a];x=n[v.attachedFaces.ffIndex];for(let z=0;z<Math.floor(a/2);z++)g=[],l=z*(a+1),w.forEach(({key:E,dir:B})=>{for(let y=0;y<a-2*z-1;y++)g.push(x.stickers[l]),l+=v.attachedFaces[E]*B}),q.stickerCollections.push(g);r=e[e.length-1];A=n[v.attachedFaces.lfIndex];for(let z=0;z<Math.floor(a/2);z++)g=[],l=z*(a+1),w.forEach(({key:E,dir:B})=>{for(let y=0;y<a-2*z-1;y++)g.push(A.stickers[l]),l+=v.attachedFaces[E]*B}),r.stickerCollections.push(g);a%2&&(q.stickerCollections.push([x.stickers[(a*
a-1)/2]]),r.stickerCollections.push([A.stickers[(a*a-1)/2]]))});e.forEach(v=>{v.stickerCollections[0].isPrimary=!0;v.computeStickerCover()});super("Cube",a,n,e);this.saveOrientation({axis:new Vector({x:0,y:1,z:0}),angle:Math.PI/4});this.saveOrientation({axis:new Vector({x:1,y:0,z:0}),angle:Math.PI/8})}}
class Tetrahedron extends Puzzle{constructor(a=3,b=200){var c=b/Math.sqrt(2);const f={steps:10,dAlpha:2*Math.PI/3/10},k={},h=[],n=[];c=[new Point(b,0,c),new Point(-b,0,c),new Point(0,b,-c),new Point(0,-b,-c)];b=[{points:[c[0],c[2],c[1]],color:"white"},{points:[c[0],c[1],c[3]],color:"blue"},{points:[c[0],c[3],c[2]],color:"lawngreen"},{points:[c[1],c[2],c[3]],color:"red"}];c=[{slices:[{fIndex:0,sIJ:e=>[e,0],dIJ:()=>[0,1]},{fIndex:1,sIJ:e=>[e,0],dIJ:()=>[0,1]},{fIndex:2,sIJ:e=>[e,0],dIJ:()=>[0,1]}],
attachedFace:{fIndex:3,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]},unitVector:(new Vector(c[0])).unit()},{slices:[{fIndex:0,sIJ:e=>[a-e-1,2*(a-e-1)],dIJ:(e,d)=>[d%2?0:1,d%2?-1:1]},{fIndex:3,sIJ:e=>[e,0],dIJ:()=>[0,1]},{fIndex:1,sIJ:e=>[a-1,2*e],dIJ:(e,d)=>[d%2?-1:0,-1]}],attachedFace:{fIndex:2,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]},unitVector:(new Vector(c[1])).unit()},{slices:[{fIndex:0,sIJ:e=>[a-1,2*e],dIJ:(e,d)=>[d%2?-1:0,-1]},{fIndex:2,sIJ:e=>[a-e-1,2*(a-e-1)],dIJ:(e,d)=>[d%2?0:1,d%2?-1:1]},{fIndex:3,
sIJ:e=>[a-1,2*e],dIJ:(e,d)=>[d%2?-1:0,-1]}],attachedFace:{fIndex:1,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]},unitVector:(new Vector(c[2])).unit()},{slices:[{fIndex:1,sIJ:e=>[a-e-1,2*(a-e-1)],dIJ:(e,d)=>[d%2?0:1,d%2?-1:1]},{fIndex:3,sIJ:e=>[a-e-1,2*(a-e-1)],dIJ:(e,d)=>[d%2?0:1,d%2?-1:1]},{fIndex:2,sIJ:e=>[a-1,2*e],dIJ:(e,d)=>[d%2?-1:0,-1]}],attachedFace:{fIndex:0,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]},unitVector:(new Vector(c[3])).unit()}];b.forEach((e,d)=>{const g=[];let l=[e.points[0].clone()],
q,r,x,A,v;const z=(new Vector(e.points[0],e.points[1])).multiply(1/a),E=(new Vector(e.points[1],e.points[2])).multiply(1/a);let B;for(let y=0;y<a;y++){q=[];B=z.add(l[0]);q.push(new Point(B.x,B.y,B.z));for(let G=0;G<=y;G++)B=E.add(B),q.push(new Point(B.x,B.y,B.z));l.forEach((G,F)=>{r=G.clone();x=q[F].clone();A=q[F+1].clone();r.id=`p-${d}-${y}-${F}`;x.id=`p-${d}-${y+1}-${F}`;A.id=`p-${d}-${y+1}-${F+1}`;r.clone();x.clone();A.clone();g.push(new Sticker(`s-${d}-${y}-${2*F}`,e.color,[r,x,A]));k[g[g.length-
1].id]=g[g.length-1];F<l.length-1&&(r=r.clone(),A=A.clone(),v=l[F+1].clone(),v.id=`q-${d}-${y}-${F+1}`,r.clone(),A.clone(),v.clone(),g.push(new Sticker(`s-${d}-${y}-${2*F+1}`,e.color,[r,A,v])),k[g[g.length-1].id]=g[g.length-1])});l=q}h.push(new Face(g))});let w,D,C,u,m,t,p;c.forEach(e=>{for(let A=0;A<a;A++)w=new Cycle(n.length,[],3,e.unitVector,f),C=[],e.slices.forEach(v=>{[u,m]=v.sIJ(A);for(let z=0;z<1+2*A;z++)[t,p]=v.dIJ(A,z),C.push(k[`s-${v.fIndex}-${u}-${m}`]),u+=t,m+=p}),w.stickerCollections.push(C),
n.push(w);w=n[n.length-1];D=e.attachedFace.fIndex;let d=a-1,g=1,l=0,q,r,x;for(;0<d;)r=x=l,C=[],e.attachedFace.steps.forEach(A=>{q=0;for(let v=0;v<d;v++){const [z,E]=A(l,q);C.push(k[`s-${D}-${r}-${x}`]);r+=z;x+=E;q+=1}}),w.stickerCollections.push(C),l+=1,d-=g,g=2===g?1:2;k[`s-${D}-${l}-${l}`]&&a%3&&w.stickerCollections.push([k[`s-${D}-${l}-${l}`]])});n.forEach(e=>{e.stickerCollections[0].isPrimary=!0;e.computeStickerCover()});super("Tetrahedron",a,h,n);this.saveOrientation({axis:new Vector({x:0,y:1,
z:0}),angle:Math.PI/3})}}
class Octahedron extends Puzzle{constructor(a=2,b=200){const c={steps:10,dAlpha:2*Math.PI/3/10},f={},k=[],h=[];b=[new Point(0,0,-b),new Point(b,0,0),new Point(0,b,0),new Point(-b,0,0),new Point(0,-b,0),new Point(0,0,b)];b=[{points:[b[0],b[2],b[1]],color:"white"},{points:[b[0],b[1],b[4]],color:"blue"},{points:[b[0],b[4],b[3]],color:"lawngreen"},{points:[b[0],b[3],b[2]],color:"skyblue"},{points:[b[5],b[1],b[2]],color:"red"},{points:[b[5],b[2],b[3]],color:"darkorange"},{points:[b[5],b[3],b[4]],color:"purple"},
{points:[b[5],b[4],b[1]],color:"yellow"}];const n=[{slices:[{fIndex:4,sIJ:d=>[a-d-1,2*(a-d-1)],dIJ:()=>[0,-1],limJ:d=>1+2*(a-d-1)},{fIndex:7,sIJ:d=>[a-d-1,2*(a-d-1)],dIJ:(d,g)=>[g%2?0:1,g%2?-1:1],limJ:d=>1+2*d},{fIndex:1,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,g%2?-1:1],limJ:d=>1+2*(a-d-1)},{fIndex:2,sIJ:d=>[d,0],dIJ:()=>[0,1],limJ:d=>1+2*d},{fIndex:3,sIJ:d=>[d,0],dIJ:(d,g)=>[g%2?0:1,1],limJ:d=>1+2*(a-d-1)},{fIndex:5,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,-1],limJ:d=>1+2*d}],attachedFaces:[{fIndex:0,
steps:[()=>[1,0],()=>[0,2],()=>[-1,-2]]},{fIndex:6,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]}],unitVector:(new Vector(new Point(1,1,-1))).unit()},{slices:[{fIndex:0,sIJ:d=>[d,0],dIJ:(d,g)=>[g%2?0:1,1],limJ:d=>1+2*(a-d-1)},{fIndex:4,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,-1],limJ:d=>1+2*d},{fIndex:7,sIJ:d=>[a-d-1,2*(a-d-1)],dIJ:()=>[0,-1],limJ:d=>1+2*(a-d-1)},{fIndex:6,sIJ:d=>[a-d-1,2*(a-d-1)],dIJ:(d,g)=>[g%2?0:1,g%2?-1:1],limJ:d=>1+2*d},{fIndex:2,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,g%2?-1:1],limJ:d=>
1+2*(a-d-1)},{fIndex:3,sIJ:d=>[d,0],dIJ:()=>[0,1],limJ:d=>1+2*d}],attachedFaces:[{fIndex:1,steps:[()=>[1,0],()=>[0,2],()=>[-1,-2]]},{fIndex:5,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]}],unitVector:(new Vector(new Point(1,-1,-1))).unit()},{slices:[{fIndex:1,sIJ:d=>[d,0],dIJ:(d,g)=>[g%2?0:1,1],limJ:d=>1+2*(a-d-1)},{fIndex:7,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,-1],limJ:d=>1+2*d},{fIndex:6,sIJ:d=>[a-d-1,2*(a-d-1)],dIJ:()=>[0,-1],limJ:d=>1+2*(a-d-1)},{fIndex:5,sIJ:d=>[a-d-1,2*(a-d-1)],dIJ:(d,g)=>[g%2?
0:1,g%2?-1:1],limJ:d=>1+2*d},{fIndex:3,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,g%2?-1:1],limJ:d=>1+2*(a-d-1)},{fIndex:0,sIJ:d=>[d,0],dIJ:()=>[0,1],limJ:d=>1+2*d}],attachedFaces:[{fIndex:2,steps:[()=>[1,0],()=>[0,2],()=>[-1,-2]]},{fIndex:4,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]}],unitVector:(new Vector(new Point(-1,-1,-1))).unit()},{slices:[{fIndex:2,sIJ:d=>[d,0],dIJ:(d,g)=>[g%2?0:1,1],limJ:d=>1+2*(a-d-1)},{fIndex:6,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,-1],limJ:d=>1+2*d},{fIndex:5,sIJ:d=>[a-d-1,2*
(a-d-1)],dIJ:()=>[0,-1],limJ:d=>1+2*(a-d-1)},{fIndex:4,sIJ:d=>[a-d-1,2*(a-d-1)],dIJ:(d,g)=>[g%2?0:1,g%2?-1:1],limJ:d=>1+2*d},{fIndex:0,sIJ:d=>[a-1,2*d],dIJ:(d,g)=>[g%2?-1:0,g%2?-1:1],limJ:d=>1+2*(a-d-1)},{fIndex:1,sIJ:d=>[d,0],dIJ:()=>[0,1],limJ:d=>1+2*d}],attachedFaces:[{fIndex:3,steps:[()=>[1,0],()=>[0,2],()=>[-1,-2]]},{fIndex:7,steps:[()=>[1,2],()=>[0,-2],()=>[-1,0]]}],unitVector:(new Vector(new Point(-1,1,-1))).unit()}];b.forEach((d,g)=>{const l=[];let q=[d.points[0].clone()],r,x,A,v,z;const E=
(new Vector(d.points[0],d.points[1])).multiply(1/a),B=(new Vector(d.points[1],d.points[2])).multiply(1/a);let y;for(let G=0;G<a;G++){r=[];y=E.add(q[0]);r.push(new Point(y.x,y.y,y.z));for(let F=0;F<=G;F++)y=B.add(y),r.push(new Point(y.x,y.y,y.z));q.forEach((F,H)=>{x=F.clone();A=r[H].clone();v=r[H+1].clone();x.id=`p-${g}-${G}-${H}`;A.id=`p-${g}-${G+1}-${H}`;v.id=`p-${g}-${G+1}-${H+1}`;x.clone();A.clone();v.clone();l.push(new Sticker(`s-${g}-${G}-${2*H}`,d.color,[x,A,v]));f[l[l.length-1].id]=l[l.length-
1];H<q.length-1&&(x=x.clone(),v=v.clone(),z=q[H+1].clone(),z.id=`q-${g}-${G}-${H+1}`,x.clone(),v.clone(),z.clone(),l.push(new Sticker(`s-${g}-${G}-${2*H+1}`,d.color,[x,v,z])),f[l[l.length-1].id]=l[l.length-1])});q=r}k.push(new Face(l))});let w,D,C,u,m,t,p,e;n.forEach(d=>{for(let g=0;g<a;g++)w=new Cycle(h.length,[],3,d.unitVector,c),C=[],d.slices.forEach(l=>{[u,m]=l.sIJ(g);e=l.limJ(g);for(let q=0;q<e;q++)[t,p]=l.dIJ(g,q),C.push(f[`s-${l.fIndex}-${u}-${m}`]),u+=t,m+=p}),w.stickerCollections.push(C),
h.push(w);d.attachedFaces.forEach((g,l)=>{w=l?h[h.length-1]:h[h.length-a];D=g.fIndex;let q=a-1;l=1;let r=0,x,A,v;for(;0<q;)A=v=r,C=[],g.steps.forEach(z=>{x=0;for(let E=0;E<q;E++){const [B,y]=z(r,x);C.push(f[`s-${D}-${A}-${v}`]);A+=B;v+=y;x+=1}}),w.stickerCollections.push(C),r+=1,q-=l,l=2===l?1:2;f[`s-${D}-${r}-${r}`]&&w.stickerCollections.push([f[`s-${D}-${r}-${r}`]])})});h.forEach(d=>{d.stickerCollections[0].isPrimary=!0;d.computeStickerCover()});super("Octahedron",a,k,h);this.saveOrientation({axis:new Vector({x:0,
y:1,z:0}),angle:Math.PI/12});this.saveOrientation({axis:new Vector({x:1,y:0,z:0}),angle:Math.PI/24})}}
class Dodecahedron extends Puzzle{constructor(a=1,b=200){var c=(1+Math.sqrt(5))/2;b/=2;var f=b*c;c=1*b/c;const k=[],h=[],n={},w={},D={steps:10,dAlpha:2*Math.PI/5/10};c=[new Point(b,b,b,"r0"),new Point(b,b,-b,"r1"),new Point(b,-b,b,"r2"),new Point(b,-b,-b,"r3"),new Point(-b,b,b,"r4"),new Point(-b,b,-b,"r5"),new Point(-b,-b,b,"r6"),new Point(-b,-b,-b,"r7"),new Point(f,c,0,"r8"),new Point(f,-c,0,"r9"),new Point(-f,c,0,"r10"),new Point(-f,-c,0,"r11"),new Point(0,f,c,"r12"),new Point(0,f,-c,"r13"),new Point(0,
-f,c,"r14"),new Point(0,-f,-c,"r15"),new Point(c,0,f,"r16"),new Point(c,0,-f,"r17"),new Point(-c,0,f,"r18"),new Point(-c,0,-f,"r19")];const C=[{points:[c[8],c[1],c[13],c[12],c[0]],color:"purple"},{points:[c[9],c[2],c[14],c[15],c[3]],color:"magenta"},{points:[c[10],c[4],c[12],c[13],c[5]],color:"white"},{points:[c[11],c[7],c[15],c[14],c[6]],color:"yellow"},{points:[c[12],c[4],c[18],c[16],c[0]],color:"pink"},{points:[c[13],c[1],c[17],c[19],c[5]],color:"blue"},{points:[c[14],c[2],c[16],c[18],c[6]],color:"green"},
{points:[c[15],c[7],c[19],c[17],c[3]],color:"crimson"},{points:[c[16],c[2],c[9],c[8],c[0]],color:"red"},{points:[c[17],c[1],c[8],c[9],c[3]],color:"lawngreen"},{points:[c[18],c[4],c[10],c[11],c[6]],color:"brown"},{points:[c[19],c[7],c[11],c[10],c[5]],color:"skyblue"}];c=u=>C[u].points.reduce((m,t)=>m.add(t),new Vector({x:0,y:0,z:0}));b=[];for(f=0;12>f;f++){const u={unitVector:c(f),slices:{length:5}};let m,t,p;for(m=0;12>m;m++)if(m!=f)for(let e=0;5>e;e++)for(let d=0;5>d;d++)C[f].points[e].id===C[m].points[d].id&&
C[f].points[mod(e+1,5)].id===C[m].points[mod(d-1,5)].id&&(t=d,p=mod(d-1,5),u.slices[e]={face:m,startV:t,endV:p});u.slices=Array.prototype.slice.apply(u.slices);b.push(u)}C.forEach((u,m)=>{const t=[];u.points.forEach((p,e)=>{var d=new Vector(p);const g=(new Vector(p,u.points[mod(e+1,u.points.length)])).multiply(1/(2*a));p=(new Vector(p,u.points[mod(e-1,u.points.length)])).multiply(1/(2*a));let l;var q;for(l=0;l<=a;l++)for(q=0;q<=a;q++){var r=d.add(g.multiply(l)).add(p.multiply(q));n[`p-${m}-${e}-${l}-${q}`]=
new Point(r.x,r.y,r.z);l&&q&&(t.push(new Sticker(`s-${m}-${e}-${l-1}-${q-1}`,u.color,[n[`p-${m}-${e}-${l}-${q}`].clone(),n[`p-${m}-${e}-${l-1}-${q}`].clone(),n[`p-${m}-${e}-${l-1}-${q-1}`].clone(),n[`p-${m}-${e}-${l}-${q-1}`].clone()])),w[t[t.length-1].id]=t[t.length-1])}r=(new Vector(u.points[mod(e,u.points.length)],u.points[mod(e-1,u.points.length)])).multiply(1/(2*a));q=(new Vector(u.points[mod(e+1,u.points.length)],u.points[mod(e+2,u.points.length)])).multiply(1/(2*a));const x=d.add(g.multiply(a));
let A,v;for(l=0;l<=a;l++)A=x.add(r.multiply(l)),v=x.add(q.multiply(l)),n[`p-m-${m}-${e}-${l}-l`]=new Point(A.x,A.y,A.z),n[`p-m-${m}-${e}-${l}-r`]=new Point(v.x,v.y,v.z),l&&(t.push(new Sticker(`s-${m}-${e}-${l-1}-${a}`,u.color,[n[`p-m-${m}-${e}-${l}-l`].clone(),n[`p-m-${m}-${e}-${l}-r`].clone(),n[`p-m-${m}-${e}-${l-1}-r`].clone(),n[`p-m-${m}-${e}-${l-1}-l`].clone()])),w[t[t.length-1].id]=t[t.length-1]);d=d.add(g.multiply(a)).add(p.multiply(a));n[`p-${m}-${e}`]=new Point(d.x,d.y,d.z)});t.push(new Sticker(`s-${m}`,
u.color,[n[`p-${m}-0`].clone(),n[`p-${m}-1`].clone(),n[`p-${m}-2`].clone(),n[`p-${m}-3`].clone(),n[`p-${m}-4`].clone()]));w[t[t.length-1].id]=t[t.length-1];k.push(new Face(t))});b.forEach((u,m)=>{let t;for(let e=0;e<a;e++){var p=new Cycle(h.length,[],5,u.unitVector,D);for(let g=0;g<a;g++){const l=[];u.slices.forEach(q=>{l.push(w[`s-${q.face}-${q.startV}-${e}-${g}`]);l.push(w[`s-${q.face}-${q.endV}-${g}-${e}`])});p.stickerCollections.push(l)}const d=[];u.slices.forEach(g=>{d.push(w[`s-${g.face}-${g.endV}-${e}-${a}`])});
p.stickerCollections.push(d);p.stickerCollections.forEach(g=>g.isPrimary=!0);h.push(p);e||(t=p)}for(u=0;u<a;u++)for(p=0;p<=a;p++){const e=[];for(let d=0;5>d;d++)e.push(w[`s-${m}-${d}-${u}-${p}`]);t.stickerCollections.push(e)}t.stickerCollections.push([w[`s-${m}`]])});h.forEach(u=>u.computeStickerCover());super("Dodecahedron",a<<1,k,h);this.saveOrientation({axis:new Vector({x:1,y:0,z:0}),angle:-Math.PI/5})}}
class Icosahedron extends Puzzle{constructor(a=2,b=200){const c={},f={},k=[],h=[],n={steps:10,dAlpha:2*Math.PI/5/10};b/=2;const w=b*(1+Math.sqrt(5))/2;b=[new Point(0,w,b,"r0"),new Point(0,w,-b,"r1"),new Point(0,-w,b,"r2"),new Point(0,-w,-b,"r3"),new Point(w,b,0,"r4"),new Point(w,-b,0,"r5"),new Point(-w,b,0,"r6"),new Point(-w,-b,0,"r7"),new Point(b,0,w,"r8"),new Point(-b,0,w,"r9"),new Point(b,0,-w,"r10"),new Point(-b,0,-w,"r11")];const D=[{points:[b[0],b[4],b[1]],color:"white"},{points:[b[0],b[1],
b[6]],color:"blue"},{points:[b[0],b[6],b[9]],color:"red"},{points:[b[0],b[9],b[8]],color:"lawngreen"},{points:[b[0],b[8],b[4]],color:"skyblue"},{points:[b[3],b[2],b[7]],color:"orange"},{points:[b[3],b[5],b[2]],color:"darkolivegreen"},{points:[b[3],b[10],b[5]],color:"yellow"},{points:[b[3],b[11],b[10]],color:"lightgreen"},{points:[b[3],b[7],b[11]],color:"salmon"},{points:[b[4],b[5],b[10]],color:"magenta"},{points:[b[1],b[10],b[11]],color:"crimson"},{points:[b[6],b[11],b[7]],color:"indigo"},{points:[b[9],
b[7],b[2]],color:"brown"},{points:[b[8],b[2],b[5]],color:"darkblue"},{points:[b[2],b[8],b[9]],color:"pink"},{points:[b[5],b[4],b[8]],color:"burlywood"},{points:[b[10],b[1],b[4]],color:"darkcyan"},{points:[b[11],b[6],b[1]],color:"darkmagenta"},{points:[b[7],b[9],b[6]],color:"goldenrod"}];D.forEach((m,t)=>m.id=t);const C={},u=[];b.forEach(m=>{const t=m.id;m={root:m,faces:[]};let p=D.find(({points:e})=>e.find(d=>d.id===t));m.faces.push(p);[].push(p.points[mod(p.points.findIndex(e=>e.id===t)+2,3)].id);
for(let e=0;4>e;e++){const d=t,g=p.points[mod(p.points.findIndex(q=>q.id===t)+1,3)].id,l=p.points[mod(p.points.findIndex(q=>q.id===t)+2,3)].id;p=D.find(({points:q})=>!q.find(r=>r.id===g)&&q.find(r=>r.id===d)&&q.find(r=>r.id===l));m.faces.push(p)}u.push(m)});D.forEach(({points:m,color:t},p)=>{var e=[],d=new Vector(m[0]),g=(new Vector(m[0],m[1])).multiply(1/a);const l=(new Vector(m[1],m[2])).multiply(1/a);let q,r,x;for(r=0;r<=a;r++)for(x=0;x<=r;x++)q=d.add(g.multiply(r)).add(l.multiply(x)),c[`p-${p}-${r}-${x}`]=
new Point(q.x,q.y,q.z),r&&x&&(e.push(new Sticker(`s-${p}-${r}-${x}`,t,[c[`p-${p}-${r-1}-${x-1}`].clone(),c[`p-${p}-${r}-${x-1}`].clone(),c[`p-${p}-${r}-${x}`].clone()])),f[e[e.length-1].id]=e[e.length-1],x<r&&(e.push(new Sticker(`s-${p}-${r}-${x}-r`,t,[c[`p-${p}-${r}-${x}`].clone(),c[`p-${p}-${r-1}-${x}`].clone(),c[`p-${p}-${r-1}-${x-1}`].clone()])),f[e[e.length-1].id]=e[e.length-1]));k.push(new Face(e));t={};t[m[0].id]=[];for(e=1;e<=a;e++){d=[];for(g=1;g<=e;g++)d.push(f[`s-${p}-${e}-${g}`]),g<e&&
d.push(f[`s-${p}-${e}-${g}-r`]);t[m[0].id].push(d)}t[m[1].id]=[];for(e=1;e<=a;e++){d=[];for(g=1;g<=e;g++)d.push(f[`s-${p}-${a-(g-1)}-${e-(g-1)}`]),g<e&&d.push(f[`s-${p}-${a-(g-1)}-${e-g}-r`]);t[m[1].id].push(d)}t[m[2].id]=[];for(e=1;e<=a;e++){d=[];for(g=1;g<=e;g++)d.push(f[`s-${p}-${a+(g-1)-(e-1)}-${a-(e-1)}`]),g<e&&d.push(f[`s-${p}-${a+1+(g-1)-(e-1)}-${a-(e-1)}-r`]);t[m[2].id].push(d)}C[p]=t});u.forEach(({faces:m,root:t})=>{for(let p=0;p<a;p++){const e=(new Vector(t)).unit(),d=[Array.prototype.concat.apply([],
m.map(({id:g})=>C[g][t.id][p]))];h.push(new Cycle(h.length,d,5,e,n))}});h.forEach(m=>{m.stickerCollections[0].isPrimary=!0;m.computeStickerCover()});super("Icosahedron",a,k,h);this.saveOrientation({axis:new Vector({x:1,y:0,z:0}),angle:-27*Math.PI/40})}}
(()=>{window.menuConfig={puzzles:{tetrahedron:(b,c)=>new Tetrahedron(b,c?42.5:void 0),cube:(b,c)=>new Cube(b,c?50:void 0),octahedron:(b,c)=>new Octahedron(b,c?42.5:void 0),dodecahedron:(b,c)=>new Dodecahedron(b,c?42.5:void 0),icosahedron:(b,c)=>new Icosahedron(b,c?42.5:void 0)},baseSizes:{tetrahedron:[3,4,5],cube:[2,3,4],octahedron:[2,3,4],dodecahedron:[1,2,3],icosahedron:[2,3,4]},sizeOffset:0};let a=0;window.updateSizeOffset=(b,c)=>{c=Math.max((parseInt(b.value)||0)+c,0);b.value=c;window.menuConfig.sizeOffset=
c};window.showShapeMenu=()=>{window.menuConfig.sizes=[];for(const [c,f]of Object.entries(window.menuConfig.baseSizes))window.menuConfig.sizes[c]=f.map(k=>k+window.menuConfig.sizeOffset);a++;window.puzzlemenu.style.display=window.shapemenu.style.display=window.settingsmenubutton.style.display="inline-block";window.configurationmenu.style.display=window.puzzlemenubutton.style.display=window.sizemenu.style.display="none";const b=a;for(const c in window.menuConfig.puzzles){const f=window[c].getContext("2d"),
k=(0,window.menuConfig.puzzles[c])(void 0,!0);k.updatedOrientation={axis:new Vector({x:1,y:1,z:0}),angle:0};f.setTransform(1,0,0,1,0,0);f.translate(50,50);const h=createAnimationFPSThrottler(),n=()=>{f.save();f.setTransform(1,0,0,1,0,0);f.clearRect(0,0,gameCanvas.width,gameCanvas.height);f.restore();k.updatedOrientation.angle+=.015;k.update();k.render(f);a===b&&h.requestAnimationFrame(n)};h.requestAnimationFrame(n);window[c].onmousedown=()=>showSizeMenu(c)}};window.showSizeMenu=b=>{a++;const c=a;
window.shapemenu.style.display=window.settingsmenubutton.style.display="none";window.sizemenu.style.display=window.puzzlemenubutton.style.display="inline-block";for(let f=0;3>f;f++){const k=window[`size-${f+1}`].getContext("2d"),h=window.menuConfig.puzzles[b],n=window.menuConfig.sizes[b][f],w=h(n,!0);w.updatedOrientation={axis:new Vector({x:1,y:1,z:0}),angle:0};k.setTransform(1,0,0,1,0,0);k.translate(50,50);animationFPSThrottler=createAnimationFPSThrottler();const D=()=>{k.save();k.setTransform(1,
0,0,1,0,0);k.clearRect(0,0,gameCanvas.width,gameCanvas.height);k.restore();w.updatedOrientation.angle+=.015;w.update();w.render(k);a===c&&animationFPSThrottler.requestAnimationFrame(D)};animationFPSThrottler.requestAnimationFrame(D);window[`size-${f+1}`].onmousedown=()=>{window.clearSolution();window.selectedPuzzle=h(n,!1);window.showStartButton()}}};window.showSettingsMenu=()=>{window.puzzlemenu.style.display=window.settingsmenubutton.style.display="none";window.configurationmenu.style.display=window.puzzlemenubutton.style.display=
"inline-block"};window.hideStartButton=()=>{window.startbutton.style.visibility="hidden"};window.showStartButton=()=>{window.startbutton.style.visibility="visible"};window.showShapeMenu()})();
(()=>{const a=gameCanvas.getContext("2d"),b=gameCanvasInverted.getContext("2d");a.translate(300,300);b.scale(1/3,1/3);b.translate(300,300);const c=()=>{const h=gameCanvas.getBoundingClientRect();return{x:h.left+300,y:h.top+300}};window.explodedStickers=!0;window.animate=!0;window.selectedPuzzle=new Tetrahedron;Puzzle.prototype.onFinish=h=>{window.help.style.display="none";window.menu.style.display="none";window.success.style.display="inline-block";window.message.innerHTML=`You solved it in ${h} seconds.<br/> Good Job.`};
const f=createAnimationFPSThrottler(),k=()=>{a.save();a.setTransform(1,0,0,1,0,0);a.clearRect(0,0,gameCanvas.width,gameCanvas.height);a.restore();window.selectedPuzzle.update();window.selectedPuzzle.render(a,!1,window.explodedStickers);window.showRearView&&(b.save(),b.setTransform(1,0,0,1,0,0),b.clearRect(0,0,gameCanvas.width,gameCanvas.height),b.restore(),window.selectedPuzzle.render(b,!0,window.explodedStickers));if(window.selectedPuzzle.startTime){var h=Math.floor(((new Date).getTime()-window.selectedPuzzle.startTime)/
1E3);let n=`${Math.floor(h/60)}`;h=`${h%60}`;2>n.length&&(n="0"+n);2>h.length&&(h="0"+h);window.stats.innerHTML=`Time Taken: ${n}:${h}, Moves Made: ${window.selectedPuzzle.movesMade}`}else window.stats.innerHTML="Time Taken: --:--, Moves Made: --";f.requestAnimationFrame(k)};f.requestAnimationFrame(k);document.addEventListener("contextmenu",h=>h.preventDefault());gameCanvas.addEventListener("mousedown",h=>{h.preventDefault();h.stopPropagation();const n=c();window.selectedPuzzle.grab(h.clientX-n.x,
h.clientY-n.y,h.ctrlKey?2:h.button)});gameCanvas.addEventListener("mousemove",h=>{h.preventDefault();h.stopPropagation();const n=c();window.selectedPuzzle.drag(h.clientX-n.x,h.clientY-n.y)});gameCanvas.addEventListener("mouseup",h=>{h.preventDefault();h.stopPropagation();window.selectedPuzzle.release()});gameCanvas.addEventListener("mouseleave",h=>{window.selectedPuzzle.release()});gameCanvas.addEventListener("touchstart",h=>{h.preventDefault();h.stopPropagation();const n=c();window.selectedPuzzle.grab(h.touches[0].clientX-
n.x,h.touches[0].clientY-n.y,1)});gameCanvas.addEventListener("touchmove",h=>{h.preventDefault();h.stopPropagation();const n=c();window.selectedPuzzle.drag(h.touches[0].clientX-n.x,h.touches[0].clientY-n.y)});gameCanvas.addEventListener("touchend",h=>{h.preventDefault();h.stopPropagation();window.selectedPuzzle.release()});gameCanvas.addEventListener("touchcancel",h=>{window.selectedPuzzle.release()})})();
(()=>{window.showSolverUnsupportedMessage=()=>{window.solverunsupported.style.display="block";window.solvewrapper.style.display="none"};window.Worker?(window.solverWorker=new Worker("src/solver-worker.js"),window.solverWorker.onerror=k=>showSolverUnsupportedMessage()):showSolverUnsupportedMessage();const a=window.solutionStack={movesMade:[],movesToMake:[]};window.updateSolutionPanel=()=>{const k=a.movesToMake.length?a.movesToMake[a.movesToMake.length-1].subSequence:"";window.solutioninfo.innerHTML=
`
            ${a.movesToMake.length?a.movesToMake[a.movesToMake.length-1].sequence:a.movesMade.length?"Solved!":"Already Solved!"}
            <br/>
            ${k?`${k}<br/>`:""}
            ${a.movesMade.length}/${a.movesMade.length+a.movesToMake.length}`;window.applysolutionpanel.style.visibility=a.movesToMake.length?"visible":"hidden";window.revertsolutionpanel.style.visibility=a.movesMade.length?"visible":"hidden"};let b=!1,c=!1,f=!1;window.clearSolution=()=>{b?c=!0:window.solutionpanel.style.display="none"};window.disableSolveButton=()=>{window.solvebutton.style.color="grey";window.solvebutton.style.borderColor="grey";f=!0};window.enableSolveButton=()=>{window.solvebutton.style.color=
"skyblue";window.solvebutton.style.borderColor="skyblue";f=!1};window.generateSolution=()=>{b||f||(b=!0,window.selectedPuzzle.clearStats(),window.solvebutton.style.display="none",window.solverstatus.style.display="block",window.solverstatustext.innerHTML=`Initializing solver for ${window.selectedPuzzle.displayName} of size ${window.selectedPuzzle.displaySize}
            <br/>(This may take minutes for large puzzles)
            `,window.solverWorker.postMessage(window.selectedPuzzle))};window.solverWorker&&(window.solverWorker.onmessage=k=>{"INITIALIZED"===k.data.status&&(window.solverstatustext.innerText=`Solving ${window.selectedPuzzle.displayName} of size ${window.selectedPuzzle.displaySize}`);"SOLVED"===k.data.status&&(window.solverstatus.style.display="none",window.solvebutton.style.display="inline-block",c||(window.solutionStack.movesMade=[],window.solutionStack.movesToMake=k.data.solution.reverse(),window.solutionpanel.style.display=
"block",updateSolutionPanel()),b=c=!1)});window.makeSolverMove=()=>{if(a.movesToMake.length){var k=a.movesToMake.pop();window.selectedPuzzle.animateAndTwist(window.selectedPuzzle.cycles[k.cycleIndex],k.direction>k.period>>1?k.direction-k.period:k.direction)?(a.movesMade.push(k),updateSolutionPanel()):a.movesToMake.push(k)}};window.revertSolverMove=()=>{if(a.movesMade.length){var k=a.movesMade.pop();window.selectedPuzzle.animateAndTwist(window.selectedPuzzle.cycles[k.cycleIndex],-(k.direction>k.period>>
1?k.direction-k.period:k.direction))?(a.movesToMake.push(k),updateSolutionPanel()):a.movesMade.push(k)}};window.makeSolverMoveSequence=()=>{if(a.movesToMake.length){for(var k=a.movesToMake[a.movesToMake.length-1].sequence;a.movesToMake.length&&a.movesToMake[a.movesToMake.length-1].sequence===k;){const h=a.movesToMake.pop();window.selectedPuzzle.cycles[h.cycleIndex].twist(h.direction);a.movesMade.push(h)}updateSolutionPanel()}};window.revertSolverMoveSequence=()=>{if(a.movesMade.length){for(var k=
a.movesMade[a.movesMade.length-1].sequence;a.movesMade.length&&a.movesMade[a.movesMade.length-1].sequence===k;){const h=a.movesMade.pop();window.selectedPuzzle.cycles[h.cycleIndex].twist(-h.direction);a.movesToMake.push(h)}updateSolutionPanel()}};window.makeAllSolverMoves=()=>{for(;a.movesToMake.length;){const k=a.movesToMake.pop();window.selectedPuzzle.cycles[k.cycleIndex].twist(k.direction);a.movesMade.push(k)}updateSolutionPanel()};window.revertAllSolverMoves=()=>{for(;a.movesMade.length;){const k=
a.movesMade.pop();window.selectedPuzzle.cycles[k.cycleIndex].twist(-k.direction);a.movesToMake.push(k)}updateSolutionPanel()}})();
